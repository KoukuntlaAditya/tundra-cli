{"version":3,"sources":["../../../src/handlers/requests.js"],"names":["handleRequest","request","response","type","params","embeddedRequest","body","embeddedResponse","console","log","blue","method","url","yellow","statusCode","requestData","interceptedOn","Date","data","reason","get","debugProfile","closestMatch","JSON","stringify","requests","concat","status","send","resetRequestsHandler","saveRequestsHandler","profileName","resetProfile","map","push","sortedRequests","chain","sortBy","value","green"],"mappings":";;;;;;;AAAA;;;;AACA;;AACA;;AACA;;;;AACA;;AACA;;;;;;;;AAEO,IAAMA;AAAA,qEAAgB,iBAAOC,OAAP,EAAgBC,QAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AACrBC,gBADqB,GACdF,QAAQG,MAAR,CAAeD,IAAf,GAAsBF,QAAQG,MAAR,CAAeD,IAArC,GAA4C,QAD9B;AAErBE,2BAFqB,GAEHJ,QAAQK,IAAR,CAAaL,OAFV;AAGrBM,4BAHqB,GAGFN,QAAQK,IAAR,CAAaJ,QAHX;;;AAK3BM,oBAAQC,GAAR,CAAY,gBAAMC,IAAN,WAAmBP,IAAnB,UAA4BE,gBAAgBM,MAA5C,SAAsDN,gBAAgBO,GAAtE,UAAgF,gBAAMC,MAAN,OAAiBN,iBAAiBO,UAAlC,OAA5F;;AAEMC,uBAPqB,GAOP;AAClBZ,wBADkB;AAElBa,6BAAe,IAAIC,IAAJ,EAFG;AAGlBC,oBAAMjB,QAAQK;AAHI,aAPO;;AAAA,kBAavBH,SAAS,WAbc;AAAA;AAAA;AAAA;;AAczBY,wBAAYI,MAAZ,GAAqBlB,QAAQmB,GAAR,CAAY,QAAZ,CAArB;;AAdyB,kBAgBrBL,YAAYI,MAAZ,KAAuB,WAhBF;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAiBU,0CAAuBlB,QAAQK,IAA/B,EAAqC,uBAAWe,YAAhD,CAjBV;;AAAA;AAiBvBN,wBAAYO,YAjBW;;AAAA;;AAqB3B,2CAAkBC,KAAKC,SAAL,CAAeT,WAAf,CAAlB;;AAEA,iCAAS,EAAEU,UAAU,uBAAWA,QAAX,CAAoBC,MAApB,CAA2BX,WAA3B,CAAZ,EAAT;;AAEAb,qBAASyB,MAAT,CAAgB,GAAhB,EAAqBC,IAArB;;AAzB2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAhB;;AAAA;AAAA;AAAA;AAAA,GAAN;;AA4BA,IAAMC,sDAAuB,SAAvBA,oBAAuB,CAAC5B,OAAD,EAAUC,QAAV,EAAuB;AACzD,uBAAS,EAAEuB,UAAU,EAAZ,EAAT;;AAEAvB,WAASyB,MAAT,CAAgB,GAAhB,EAAqBC,IAArB;AACD,CAJM;;AAMA,IAAME;AAAA,sEAAsB,kBAAO7B,OAAP,EAAgBC,QAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAC3B6B,uBAD2B,GACb9B,QAAQK,IAAR,CAAayB,WADA;AAE3BC,wBAF2B,GAEZ/B,QAAQK,IAAR,CAAa0B,YAFD;AAI7BP,oBAJ6B,GAIlB,uBAAWA,QAAX,CAAoBQ,GAApB,CAAwB;AAAA,qBAAWhC,QAAQiB,IAAnB;AAAA,aAAxB,CAJkB;;AAAA,gBAM5Bc,YAN4B;AAAA;AAAA;AAAA;;AAAA,2BAO/BP,QAP+B,CAOtBS,IAPsB;AAAA,2BAO/BT,QAP+B;AAAA;AAAA;AAAA,mBAOR,yCAA2BM,WAA3B,CAPQ;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAS3BI,0BAT2B,GASV,sBAAEV,QAAF,EAAYW,KAAZ,GACpBC,MADoB,CACb,gBADa,EAEpBA,MAFoB,CAEb,aAFa,EAGpBC,KAHoB,EATU;AAAA;AAAA,mBAc3B,oCAAsBH,cAAtB,EAAsCJ,WAAtC,CAd2B;;AAAA;;AAgBjCvB,oBAAQC,GAAR,CAAY,gBAAM8B,KAAN,qDAA8DR,WAA9D,gBAAZ;;AAEA7B,qBAASyB,MAAT,CAAgB,GAAhB,EAAqBC,IAArB;;AAlBiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAtB;;AAAA;AAAA;AAAA;AAAA,GAAN","file":"requests.js","sourcesContent":["import chalk from 'chalk';\nimport { getState, setState } from '../services/state';\nimport { getExistingProfileRequests, saveRequestsAsProfile } from '../services/profile';\nimport _ from 'lodash';\nimport { sendSocketMessage } from '../services/socket';\nimport { getClosestProfileMatch } from '../services/closestMatch';\n\nexport const handleRequest = async (request, response) => {\n  const type = request.params.type ? request.params.type : 'normal';\n  const embeddedRequest = request.body.request;\n  const embeddedResponse = request.body.response;\n\n  console.log(chalk.blue(`--> [${type}] ${embeddedRequest.method} ${embeddedRequest.url} `) + chalk.yellow(`(${embeddedResponse.statusCode})`));\n\n  const requestData = {\n    type,\n    interceptedOn: new Date(),\n    data: request.body\n  };\n\n  if (type === 'unmatched') {\n    requestData.reason = request.get(\"Reason\");\n\n    if (requestData.reason === \"Not Found\") {\n      requestData.closestMatch = await getClosestProfileMatch(request.body, getState().debugProfile);\n    }\n  }\n\n  sendSocketMessage(JSON.stringify(requestData));\n\n  setState({ requests: getState().requests.concat(requestData) });\n\n  response.status(201).send();\n};\n\nexport const resetRequestsHandler = (request, response) => {\n  setState({ requests: [] });\n\n  response.status(200).send();\n};\n\nexport const saveRequestsHandler = async (request, response) => {\n  const profileName = request.body.profileName;\n  const resetProfile = request.body.resetProfile;\n\n  let requests = getState().requests.map(request => request.data);\n\n  if (!resetProfile)\n    requests.push(...await getExistingProfileRequests(profileName));\n\n  const sortedRequests = _(requests).chain()\n    .sortBy('request.method')\n    .sortBy('request.url')\n    .value();\n\n  await saveRequestsAsProfile(sortedRequests, profileName);\n\n  console.log(chalk.green(`Captured requests successfully stored as the \\'${profileName}\\' profile`));\n\n  response.status(200).send();\n};\n\n\n"]}